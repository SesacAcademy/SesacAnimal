# 📝 프로젝트 소개

![image](https://github.com/SesacAcademy/SesacAnimal/assets/55624470/37b816ce-9cb4-4934-866d-9782e64e9ea7)

<br/>

> 매년 유기견들이 늘어남에 따라 많은 유기견들에게 보호와 돌봄이 필요하지만 자원이 부족한 상황입니다.
>
> 새싹 애니멀은 이러한 상황을 개선하고 유기견에게 더 나은 미래를 제공하기 위해 유기견 입양/임보 서비스를 제공합니다. <br/> <br/>
> 개발 인원 : 4명 (박성수, 류명한, 이경진, 손승범) <br/>
> 개발 기간 : 2023.11.01 ~ 2023.11.17

### Members

<table>
  <tr>
  	<td align="center">
      <a href="https://github.com/akgkfk3">
        <img
          src="https://avatars.githubusercontent.com/u/55624470?s=400&u=ce4242f40204eaf9a56687b9a2e510e3e805e505&v=4"
          width="100px;"
        /><br />박성수(BE)</a><br />
		팀장
    </td>
	<td align="center">
      <a href="https://github.com/devsince2021">
	<img
          src="https://avatars.githubusercontent.com/u/77978026?v=4"    
          width="100px;" 
        /><br />류명한(BE)</a><br />
		팀원
    </td>
    <td align="center">
      <a href="https://github.com/dev-lkj">
        <img
          src="https://avatars.githubusercontent.com/u/96426410?v=4"
          width="100px;"
        /><br />이경진(BE)</a><br />
	    	팀원
    </td>
    <td align="center">
      <a href="https://github.com/sonnbeom">
        <img
          src="https://avatars.githubusercontent.com/u/127067296?v=4"
          width="100px;"
        /><br />손승범(BE)</a><br />
	    	팀원
    </td>
  </tr>
</table>

<br/>

## 💁‍♂️ Wiki

- 📅 [개발 일정](https://github.com/SesacAcademy/SesacAnimal/wiki/%F0%9F%93%85-%EA%B0%9C%EB%B0%9C-%EC%9D%BC%EC%A0%95)
- 🌐 [실서버 링크 (배포완료)](https://toyproject.shucloud.site/)
- 📌 [Ground Rule](https://github.com/SesacAcademy/SesacAnimal/wiki/%F0%9F%93%8C-Ground-Rule)
- 🤙 [컨벤션](https://github.com/SesacAcademy/SesacAnimal/wiki/%F0%9F%A4%99-%EC%BB%A8%EB%B2%A4%EC%85%98)
- 📁 [디렉토리 구조](https://github.com/SesacAcademy/SesacAnimal/wiki/%F0%9F%93%81-%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC-%EA%B5%AC%EC%A1%B0)
- 📜 [API 명세서](https://documenter.getpostman.com/view/28283234/2s9YRB2rty)
- 🖼️ [와이어프레임](https://www.figma.com/file/HCFnoJsXRjHzAwIavRGfh4/Sesac-Animal?type=design&node-id=28-2&mode=design)
- 📚 [다이어그램 (클래스, 시퀀스)](<https://github.com/SesacAcademy/SesacAnimal/wiki/%F0%9F%93%9A-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8-(%ED%81%B4%EB%9E%98%EC%8A%A4,-%EC%8B%9C%ED%80%80%EC%8A%A4)>)

<br/>

## 🛠 사용 기술

<b>[Front-end]</b>
<br/>
<img src="https://img.shields.io/badge/html5-E34F26?style=for-the-badge&logo=html5&logoColor=white">
<img src="https://img.shields.io/badge/css3-1572B6?style=for-the-badge&logo=css3&logoColor=white">
<img src="https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black">
<br/>
<img src="https://img.shields.io/badge/BootStrap-7952B3?style=for-the-badge&logo=BootStrap&logoColor=white">
<img src="https://img.shields.io/badge/jQuery-0769AD?style=for-the-badge&logo=jQuery&logoColor=white">
<img src="https://img.shields.io/badge/fontawesome-339AF0?style=for-the-badge&logo=fontawesome&logoColor=white">

<b>[Back-end]</b>
<br/>
<img src="https://img.shields.io/badge/OpenJDK 17-999999?style=for-the-badge&logo=OpenJDK&logoColor=white">
<img src="https://img.shields.io/badge/mysql 8.0-4479A1?style=for-the-badge&logo=mysql&logoColor=white">
<img src="https://img.shields.io/badge/Redis 5.0.3-DC382D?style=for-the-badge&logo=redis&logoColor=white">
<br/>
<img src="https://img.shields.io/badge/spring 5.3-6DB33F?style=for-the-badge&logo=spring&logoColor=white">
<img src="https://img.shields.io/badge/springboot 2.7-6DB33F?style=for-the-badge&logo=springBoot&logoColor=white">
<img src="https://img.shields.io/badge/spring security 5.7-6DB33F?style=for-the-badge&logo=springsecurity&logoColor=white">
<br/>
<img src="https://img.shields.io/badge/Hibernate 5.1-59666C?style=for-the-badge&logo=hibernate&logoColor=white">
<img src="https://img.shields.io/badge/spring data jpa 2.7-A81C7D?style=for-the-badge">
<img src="https://img.shields.io/badge/QueryDSL 5.0-A81C7D?style=for-the-badge">

<b>[Tool & Environment]</b>
<br/>
<img src="https://img.shields.io/badge/git-F05032?style=for-the-badge&logo=git&logoColor=white">
<img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white">
<img src="https://img.shields.io/badge/gradle-02303A?style=for-the-badge&logo=gradle&logoColor=white">
<img src="https://img.shields.io/badge/linux-FCC624?style=for-the-badge&logo=linux&logoColor=black">
<img src="https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&logo=Docker&logoColor=black">
<img src="https://img.shields.io/badge/postman-FF6C37?style=for-the-badge&logo=postman&logoColor=white">
<br/>
<br/>

## 🔨 시스템 아키텍처

![image](https://github.com/SesacAcademy/SesacAnimal/assets/55624470/1ffa4dcf-22c2-4451-a8e0-f7458b4f53b1)

<br/>

## 🗒️ ERD 설계

- [ERD 링크](https://www.erdcloud.com/d/ThYDwhruPuZBwNyE9)

![image](https://github.com/SesacAcademy/SesacAnimal/assets/55624470/3574c649-eea8-4932-83ad-f772b691c36c)

<br/>

## 💡 주요 업무

#### 👩‍👧 회원 (박성수)

- 이메일 인증을 통한 회원가입 기능
  - 📌 Code - [[회원가입_서비스]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/member/service/MemberServiceImp.java#L58) [[메일 인증_프로바이더]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/global/common/provider/MailAuthCodeProvider.java#L72)
  - 🔀 [Flow Chart](https://shu0622.notion.site/shu0622/Flow-Chart-8a9a4fc2c2ff438085c21cd695ab0e31)


- (Spring Security 활용) JWT 토큰 기반 방식의 로그인 기능
  
  - 📌 Code - [[로그인_컨트롤러]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/member/controller/LoginController.java#L59) [[JWT_예외 필터]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/global/common/filter/JwtExceptionFilter.java#L32) [[JWT_인증 필터]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/global/common/filter/JwtAuthenticationFilter.java#L32) [[JWT 토큰_프로바이더]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/global/common/provider/JwtTokenProvider.java#L58)
  - 🔀 [Flow Chart](https://shu0622.notion.site/shu0622/Flow-Chart-8a9a4fc2c2ff438085c21cd695ab0e31#9c32c40340584311843f616c662a8380)

- 카카오 플랫폼을 이용한 소셜 로그인 기능
  - Code - 📌 [[로그인_컨트롤러]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/member/controller/LoginController.java#L86)

- 사용자 정보를 통한 아이디 찾기, SMS 문자 인증을 통한 비밀번호 찾기 기능
  - 📌 Code - [[아이디 찾기_서비스]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/member/service/MemberServiceImp.java#L197) [[비밀번호 찾기_서비스]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/member/service/MemberServiceImp.java#L158) [[문자 인증_프로바이더]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/global/common/provider/SmsAuthCodeProvider.java#L37)
  - 🔀 Flow Chart - [[아이디 찾기]](https://shu0622.notion.site/shu0622/Flow-Chart-8a9a4fc2c2ff438085c21cd695ab0e31#c36c3add9b4f49678fc25a04be0a4183) [[비밀번호 찾기]](https://shu0622.notion.site/shu0622/Flow-Chart-8a9a4fc2c2ff438085c21cd695ab0e31#4529c9e978d247519979442eed80a2a3)

- MyPage 에서의 회원 탈퇴, 비밀번호 변경, 내 게시글 목록 기능
  - 📌 Code - [[회원 탈퇴_컨트롤러]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/member/controller/MyPageController.java#L63) [[비밀번호 변경_컨트롤러]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/member/controller/MyPageController.java#L98) [[내 게시글 목록_컨트롤러]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/member/controller/MyPageController.java#L117)
  - 🔀 Flow Chart - [[회원 탈퇴]](https://shu0622.notion.site/shu0622/Flow-Chart-8a9a4fc2c2ff438085c21cd695ab0e31#d7343e687a8148a0b12d2b148931e23c) [[비밀번호 변경]](https://shu0622.notion.site/shu0622/Flow-Chart-8a9a4fc2c2ff438085c21cd695ab0e31#2c1f8f503d7c41969da4a4974664a533) [[내 게시글 목록]](https://shu0622.notion.site/shu0622/Flow-Chart-8a9a4fc2c2ff438085c21cd695ab0e31#062fd5802ff0409b874b5e0b052f4b78)

- Oracle Cloud 및 Docker를 활용한 기본 인프라 구축

- Gitea 및 Jenkins CI/CD Pipeline 구축

- Certbot, Let's Encrypt 이용하여 HTTPS 적용 (SSL-Offloading)

#### 🚨 실종 (류명한)

- Redis를 사용하여 게시글 별로 '좋아요 count'를 캐싱 📌 [[게시글_서비스]](https://github.com/SesacAcademy/SesacAnimal/blob/53c13d605969c36d2e8a70b4d4d4c364014cb3cd/src/main/java/com/project/animal/missing/service/MissingPostServiceImpl.java#L60C1-L85C4)
  [[좋아요_서비스]](https://github.com/SesacAcademy/SesacAnimal/blob/53c13d605969c36d2e8a70b4d4d4c364014cb3cd/src/main/java/com/project/animal/missing/service/MissingLikeServiceImpl.java#L32C1-L37C1)
  [[캐시_서비스]](https://github.com/SesacAcademy/SesacAnimal/blob/53c13d605969c36d2e8a70b4d4d4c364014cb3cd/src/main/java/com/project/animal/missing/service/MissingLikeCacheServiceImpl.java#L24C1-L37C4)
  <br />
  _-> 게시글 목록에서 '좋아요 count' 노출시 효율성 향상_

- '좋아요' 호출시 Redis와 db 동시 갱신을 통한 동기화 📌 [[좋아요_서비스]](https://github.com/SesacAcademy/SesacAnimal/blob/53c13d605969c36d2e8a70b4d4d4c364014cb3cd/src/main/java/com/project/animal/missing/service/MissingLikeServiceImpl.java#L55-L82)
  [[캐시_서비스]](https://github.com/SesacAcademy/SesacAnimal/blob/2d9c2dc57077e5e9d376245170cc2e9a9d96d619/src/main/java/com/project/animal/missing/service/MissingLikeCacheServiceImpl.java#L51C1-L60C4)
  [[레디스_서비스]](https://github.com/SesacAcademy/SesacAnimal/blob/2d9c2dc57077e5e9d376245170cc2e9a9d96d619/src/main/java/com/project/animal/global/common/provider/RedisServiceProvider.java#L105C3-L123C6)
  <br />
  _-> Redis의 INCR와 DECR를 사용하여 동시성 확보_

- 복합 조건으로 필터링하는 기능 구현 📌 [[게시글_레포지토리]](https://github.com/SesacAcademy/SesacAnimal/blob/2d9c2dc57077e5e9d376245170cc2e9a9d96d619/src/main/java/com/project/animal/missing/repository/CustomMissingPostRepositoryImpl.java#L29C1-L62C4)
  <br /> -> Querydsl을 사용하여 동적 쿼리 구현

- 테스트 코드 작성 📌 [[컨트롤러_테스트]](https://github.com/SesacAcademy/SesacAnimal/blob/2d9c2dc57077e5e9d376245170cc2e9a9d96d619/src/main/java/com/project/animal/missing/repository/CustomMissingPostRepositoryImpl.java#L29C1-L62C4)
  [[서비스_테스트]](https://github.com/SesacAcademy/SesacAnimal/blob/2d9c2dc57077e5e9d376245170cc2e9a9d96d619/src/test/java/com/project/animal/missing/controller/MissingControllerTest.java#L54C3-L139C4)
  <br /> -> Junit5를 사용하여 테스트 작성

- 메소드의 실행 속도 측정을 위한 AOP 작성 📌 [[프로파일_AOP]](https://github.com/SesacAcademy/SesacAnimal/blob/2d9c2dc57077e5e9d376245170cc2e9a9d96d619/src/main/java/com/project/animal/global/common/aop/ProfileAspect.java#L1C1-L33C2)
  <br /> -> 클래스 레벨과 메소드 레벨에 모두 적용가능

#### 🐈 입양/임보 (이경진)

#### ✏️ 입양 후기 (손승범)
- 계층 구조를 활용해 댓글, 대댓글 구현 📌 [[코드 확인 1]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/review/service/ReviewCommentService.java#L68) [[코드 확인 2]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/review/repository/ReviewCommentCustomRepository.java#L25)
  
- 제목, 작성자, 내용을 통한 검색 기능 구현 📌 [[코드 확인 1]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/review/repository/ReviewPostCustomRepository.java#L29) [[코드 확인 2]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/review/service/ReviewService.java#L72)
  
- 좋아요순, 조회순에 따른 정렬 기능  구현 📌 [[코드 확인 1]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/review/repository/ReviewPostCustomRepository.java#L71) [[코드 확인 2]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/review/service/ReviewService.java#L55)

<br/>

## 🌟 트러블 슈팅

<details>
<summary>박성수</summary>
<hr/>

- 📌 [[코드 확인]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/global/common/filter/JwtExceptionFilter.java#L87)
<table>
  	<tr>
  		<td align="center">
      			문제 상황
    		</td>
		<td>
      			JWT 리프레시 토큰 만료 시, 토큰이 담긴 쿠키가 삭제되지 않음
    		</td>
  	</tr>
	<tr>
		<td align="center">
			원인
		</td>
		<td>
   			HttpServletRequest 객체에 담긴 쿠키는 단순히 Key-Value 값만을 가지고 있기 Cookie 객체에 setMaxAge() 외에 추가적인 설정 필요
    		</td>
	</tr>
 	<tr>
     		<td align="center">
			해결
		</td>
		<td>
      			만료 날짜 (setMaxage), 경로 (setPath), 값 (setValue)을 지정하여 쿠키를 삭제
    		</td>
      	</tr>
</table>

<pre>
<code>[Before]
private void removeTokenInCookie(HttpServletRequest request, HttpServletResponse response) {
	// request 객체에서 JWT Token이 담긴 Cookie를 List 형태로 가져 온다.
	List<Cookie> cookielist = Arrays.stream(request.getCookies())
			.filter(cookie -> {
				return cookie.getName().equals(JWT_ACCESS_TOKEN) || cookie.getName().equals(JWT_REFRESH_TOKEN);})
			.toList();

	// cookie의 타임 아웃을 0으로 만들고 다시 response 객체에 저장한다.
	cookielist.forEach(cookie -> {
		cookie.setMaxAge(0);
		response.addCookie(cookie);
	});
}
</code>
</pre>

<pre>
<code>[After]
private void removeTokenInCookie(HttpServletRequest request, HttpServletResponse response) {
	// request 객체에서 JWT Token이 담긴 Cookie를 List 형태로 가져 온다.
	List<Cookie> cookielist = Arrays.stream(request.getCookies())
			.filter(cookie -> {
				return cookie.getName().equals(JWT_ACCESS_TOKEN) || cookie.getName().equals(JWT_REFRESH_TOKEN);})
			.toList();

	// cookie의 타임 아웃을 0으로 만들고 다시 response 객체에 저장한다.
	cookielist.forEach(cookie -> {
		cookie.setMaxAge(0);
		cookie.setPath("/");
            	cookie.setValue(null);
		response.addCookie(cookie);
	});
}
</code>
</pre>

<hr/>
<table>
  	<tr>
  		<td align="center">
      			문제 상황  
    		</td>
		<td>
      			Controller에서 Redirect 시, 브라우저에서 Redirect된 주소로 이동하지 못함
    		</td>
  	</tr>
	<tr>
		<td align="center">
			원인
		</td>
		<td>
   			HTTP 요청은 로드밸런서를 통해 Tomcat으로 전달되고 외부 통신은 HTTPS, 내부 통신은 HTTP를 이용하기 때문에 Controller에서 Redirect 시, Location 헤더에는 "http://~~" 값이 들어가기 때문
    		</td>
	</tr>
 	<tr>
     		<td align="center">
			해결
		</td>
		<td>
      			내부 통신도 Self-Signed Key를 생성하여 HTTPS 통신을 해도 되지만 HTTP(80)으로 요청 시, HTTPS(443)으로 Redirect 하도록 HAProxy 설정을 추가
    		</td>
      	</tr>
</table>

<pre>
<code>[Before]
#---------------------------------------------------------------------
# main frontend which proxys to the backends
#---------------------------------------------------------------------
frontend main
    bind *:443 ssl crt /etc/haproxy/server.pem
    log 127.0.0.1:514 local1
    default_backend             app

#---------------------------------------------------------------------
# round robin balancing between the various backends
#---------------------------------------------------------------------
backend app
    balance     roundrobin
    server  was01 192.168.0.105:8001 check
    server  was02 192.168.0.105:8002 check
    server  was03 192.168.0.105:8003 check
</code>
</pre>

<pre>
<code>[After]
#---------------------------------------------------------------------
# main frontend which proxys to the backends
#---------------------------------------------------------------------
frontend main
    bind *:80
    bind *:443 ssl crt /etc/haproxy/server.pem
    http-request redirect scheme https unless { ssl_fc }
    log 127.0.0.1:514 local1
    default_backend             app

#---------------------------------------------------------------------
# round robin balancing between the various backends
#---------------------------------------------------------------------
backend app
    balance     roundrobin
    server  was01 192.168.0.105:8001 check
    server  was02 192.168.0.105:8002 check
    server  was03 192.168.0.105:8003 check
</code>
</pre>

<hr/>
 
</details>

<details>
<summary>류명한</summary>
<hr/>

- 📌 [[코드 확인]](https://github.com/SesacAcademy/SesacAnimal/blob/2d9c2dc57077e5e9d376245170cc2e9a9d96d619/src/main/java/com/project/animal/missing/service/MissingLikeCacheServiceImpl.java#L51C1-L60C4)

<table>
  	<tr>
  		<td align="center">
      			문제 #1
    		</td>
			<td>
      			Redis의 캐싱된 좋아요 Count를 갱신할 때 동시성 이슈 발생
    		</td>
  	</tr>
  	</tr>
	<tr>
		<td align="center">
			원인
		</td>
		<td>
   			get과 set 연산 사이에 다른 스레드의 요청에 의해 값이 변경될 수 있음
    		</td>
	</tr>
 	<tr>
     		<td align="center">
			해결
		</td>
		<td>
      			redis에서 제공하는 원자성을 보장하는 함수를 사용하여 해결 (incr, dec)
    		</td>
      </tr>
</table>

<pre>
<code>[Before]
@Override
  public void update(long postId, int status) {
    String likeCountKey = cachePrefix + postId;
    Optional<String> maybeCurrentCount = redisServiceProvider.get(likeCountKey);

    int currentCount = maybeCurrentCount.isPresent()
            ? Integer.parseInt(maybeCurrentCount.get())
            : missingLikeRepository.likedCountByPostId(postId);

    int nextCount = status == ADD
            ? addCount(currentCount)
            : subCount(currentCount);

    redisServiceProvider.save(likeCountKey, nextCount);
  }


  private int addCount(int currentCount) {
    return currentCount + 1;
  }

  private int subCount(int currentCount) {
    return currentCount > 0 ? currentCount - 1 : 0;
  }
</code>
</pre>

<pre>
<code>[After]
  @Override
  public Optional<Integer> getCountByPostId(long postId) {
    String likeCountKey = cachePrefix + postId;
    Optional<String> maybeCurrentCount = redisServiceProvider.get(likeCountKey);

    Integer currentCount = maybeCurrentCount.isPresent()
            ? Integer.parseInt(maybeCurrentCount.get())
            : null;

    return Optional.ofNullable(currentCount);
  }

  @Override
  public void updateLike(long postId, int status) {
    String likeCountKey = cachePrefix + postId;

    if (status == ADD) {
      redisServiceProvider.increase(likeCountKey); // 함수 내부에서 incr 실행
    } else {
      redisServiceProvider.decrease(likeCountKey); // 함수 내부에서 decr 실행
    }
  }
</code>
</pre>

<hr/>

<table>
  	<tr>
  		<td align="center">
      			문제 #2
    		</td>
			<td>
      			게시판 목록에서 게시글 별로 좋아요 숫자를 표현하는 로직이 비효율적인 상황
    		</td>
  	</tr>
  	</tr>
	<tr>
		<td align="center">
			원인
		</td>
		<td>
   			초기 테이블 설계 좋아요 숫자 표현이 고려되지 않음
    		</td>
	</tr>
	<tr>
		<td align="center">
			옵션
		</td>
		<td>
   			좋아요 테이블을 반정규화 vs 미리 집계한 count를 별도의 장소에 캐싱
    		</td>
	</tr>
 	<tr>
     		<td align="center">
			선택
		</td>
		<td>
      			Redis를 사용하여 게시글 별 좋아요 숫자를 캐싱함
    		</td>
      </tr>
			<tr>
     		<td align="center">
			근거
		</td>
		<td>
      			1. 프로젝트에서 이미 Redis를 사용 중이기 때문에, 즉시 사용가능한 상황 <br/> 2. 테이블 구조를 변경하는 것은 서비스 전반에 영향을 미치기 때문에 개발 후반부에 작업하기에 부적절하다고 판단
    		</td>
      </tr>
</table>

<hr/>

</details>
</details>

<details>
<summary>이경진</summary>

<table>
  	<tr>
  		<td align="center">
      			문제 상황  
    		</td>
		<td>
      			작성 예정
    		</td>
  	</tr>
	<tr>
		<td align="center">
			원인
		</td>
		<td>
   			작성 예정
    		</td>
	</tr>
 	<tr>
     		<td align="center">
			해결
		</td>
		<td>
      			작성 예정
    		</td>
      	</tr>
</table>
</details>

<details>
<summary>손승범</summary>

<hr/>

- 📌 [[코드 확인]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/review/repository/ReviewPostCustomRepository.java#L69)
<table>
  	<tr>
  		<td align="center">
      			문제#1 
    		</td>
		<td>
      			1. 좋아요순으로 게시글 조회시 데이터 정렬을 어플리케이션에서 처리<br> -> 이에 따른 어플리케이션 과부하 가능성 존재 
    		</td>
  	</tr>
	<tr>
		<td align="center">
			원인
		</td>
		<td>
   			1. 초기 ERD 설계 시 게시글 좋아요 숫자 반영하지 않음<br>
				2. DB에서 조회시 쿼리를 통해 데이터 정렬하지 않음
    		</td>
	</tr>
 	<tr>
		<td align="center">
			옵션
		</td>
		<td>
   			좋아요 테이블을 반정규화 vs 각 게시글 별로 좋아요 숫자만큼 그룹화하여 그 크기별로 정렬
    		</td>
	</tr>
 	<tr>
     		<td align="center">
			선택
		</td>
		<td>
      			각 게시글 별로 좋아요 숫자만큼 그룹화하여 그 크기별로 정렬
    		</td>
      </tr>
			<tr>
     		<td align="center">
			근거
		</td>
		<td>
      			개발 일정이 얼마 남지 않은 상황에서 테이블 구조를 변경하는 것은 협업, 코드 수정에 있어서 예측불가의 과업이 생길 수 있다고 판단
    		</td>
      </tr>
</table>

<pre>
<code>[Before]
   public Page<ReviewPost> findAllByType(String type, Pageable pageable) {
        QReviewPost reviewPost = QReviewPost.reviewPost;
        QMember member = QMember.member;
        QReviewImage reviewImage = QReviewImage.reviewImage;

        BooleanBuilder builder = new BooleanBuilder();
        builder.and(reviewPost.isActive.eq(1));

        JPAQuery<ReviewPost> query = jpaQueryFactory
                .selectFrom(reviewPost)
                .leftJoin(reviewPost.member, member).fetchJoin()
                .where(builder);

        if ("view".equals(type)) {
            query.orderBy(reviewPost.viewCount.desc());
        } else if ("like".equals(type)) {
            query.groupBy(reviewPost.id)
                    .orderBy(reviewPost.reviewPostLikes.size().desc());
        }

        List<ReviewPost> content = query
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize())
                .fetch();

        long total = jpaQueryFactory
                .selectFrom(reviewPost)
                .leftJoin(reviewPost.member, member)
                .leftJoin(reviewPost.reviewImages, reviewImage)
                .where(builder)
                .fetchCount();

        return new PageImpl<>(content, pageable, total);
    }
</code>
</pre>

<pre>
<code>[After]
public Page<ReviewPost> findAllByType(String type, Pageable pageable) {

        BooleanBuilder builder = new BooleanBuilder();
        builder.and(reviewPost.isActive.eq(1));

        JPAQuery<ReviewPost> query = jpaQueryFactory
                .selectFrom(reviewPost)
                .leftJoin(reviewPost.member, member).fetchJoin()
                .leftJoin(reviewPost.reviewPostLikes, reviewPostLike)
                .where(builder);

        if ("view".equals(type)) {
            query.orderBy(reviewPost.viewCount.desc());
        } else if ("like".equals(type)) {
            query.groupBy(reviewPost.id)
                    .orderBy(reviewPostLike.count().desc());
        }

        List<ReviewPost> content = query
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize())
                .fetch();

        long total = jpaQueryFactory
                .selectFrom(reviewPost)
                .where(builder)
                .fetchCount();

        return new PageImpl<>(content, pageable, total);
    }
</code>
</pre>
- 📌 [[코드 확인]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/review/repository/ReviewCommentCustomRepository.java#25)
<table>
  	<tr>
  		<td align="center">
      			문제#2
    		</td>
		<td>
      			데이터 중복 로드, N+1로 인한 불필요한 쿼리 발생
    		</td>
  	</tr>
	<tr>
		<td align="center">
			원인
		</td>
		<td>
   				N+1 문제 발생을 위해 컬렉션을 패치조인하여 데이터 중복이 발생
    		</td>
	</tr>
 	<tr>
     		<td align="center">
			해결
		</td>
		<td>
      			1. ToMany를 로드할 때는 Batch 활용 <br>
				2. 가져와야 할 컬렉션의 양이 제한적이라면 Batch 활용이 아닌 직접 쿼리 작성 <br>
				3. ToOne을 로드할 때는 Fetch Join 활용 <br>
    		</td>
      </tr>
			
</table>

<pre>
<code>[Before]
     @Query(value = "SELECT p FROM ReviewPost p JOIN FETCH p.member m LEFT JOIN FETCH p.		reviewImages i WHERE p.isActive = 1",
            countQuery = "SELECT count(p.id) FROM ReviewPost p WHERE p.isActive = 1")
    Page<ReviewPost> findAllPrevious(Pageable pageable);
</code>
</pre>

<pre>
<code>[After]
 @Query(value = "SELECT p FROM ReviewPost p JOIN FETCH p.member m WHERE p.isActive = 1",
            countQuery = "SELECT count(p.id) FROM ReviewPost p WHERE p.isActive = 1")
    Page<ReviewPost> findAll(Pageable pageable);


	//댓글의 데이터가 방대할 시에 Batch를 활용해 가져온다면 불필요한 데이터를 로드할 것이라고 판단
	//후에 내부 결정에 따른 limit을 걸 수 있게 쿼리 직접 작성
	public List<ReviewComment> findAllByPostId(Long reviewPostId){
        QReviewComment reviewComment = QReviewComment.reviewComment;
        QMember member = QMember.member;
        return jpaQueryFactory.selectFrom(reviewComment)
                .leftJoin(reviewComment.member)
                .fetchJoin()
                .leftJoin(reviewComment.parentComment)
                .fetchJoin()
                .where(reviewComment.reviewPost.id.eq(reviewPostId))
                .orderBy(reviewComment.parentComment.id.asc().nullsFirst(), reviewComment.createdAt.desc())
                .fetch();
    }
</code>
</pre>
</details>

<br/>

## 👩‍💻 리팩토링

<details>
<summary>박성수</summary>

<hr/>

- 📌 [[코드 확인]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/global/common/resolver/MemberDtoArgumentResolver.java#L37)

<table>
  	<tr>
  		<td align="center">
      			Before
    		</td>
		<td>
      			도메인별 Controller에서 사용자 정보 (MemberDto)를 얻기 위해, JWT 토큰에 담긴 클레임을 직접 파싱
    		</td>
  	</tr>
	<tr>
		<td align="center">
			After
		</td>
		<td>
   			MemberDto에 맞는 ArgumentResolver를 추가하여 Controller에서 직접 파싱하지 않도록 변경 (중복 코드 제거)
    		</td>
	</tr>
</table>

<pre>
@Slf4j
@Component
@RequiredArgsConstructor
public class MemberDtoArgumentResolver implements HandlerMethodArgumentResolver {

    private final JwtTokenProvider jwtTokenProvider;

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        boolean hasMemberAnnotation = parameter.hasParameterAnnotation(Member.class);
        boolean hasMemberType = MemberDto.class.isAssignableFrom(parameter.getParameterType());

        return hasMemberAnnotation && hasMemberType;
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {

        HttpServletRequest request = (HttpServletRequest) webRequest.getNativeRequest();

        String token = jwtTokenProvider.resolveToken(request, JWT_ACCESS_TOKEN);

        // 기존 쿠키에 JWT Access 토큰이 없는 경우, Request 영역에 저장해둔 newAccessToken을 사용
        if (token == null && request.getAttribute(JWT_ACCESS_TOKEN) != null)
            token = (String) request.getAttribute(JWT_ACCESS_TOKEN);

        // 기존 쿠키에 JWT Access 토큰이 있는 경우, JWT를 파싱하여 MemberDto 객체로 리턴
        if (token != null)
            return jwtTokenProvider.parseToken(token);

        // 없으면 null 값 리턴
        return null;
    }
}
</code>
</pre>

<hr/>

</details>

<details>
<summary>류명한</summary>
<hr/>

- 📌 [[코드 확인]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/missing/repository/CustomMissingPostRepositoryImpl.java)

<table>
  	<tr>
  		<td align="center">
      			Before
    		</td>
		<td>
      			BooleanBuilder와 반복되는 if문을 사용하여 필터를 위한 동적 쿼리 생성
    		</td>
  	</tr>
	<tr>
		<td align="center">
			After
		</td>
		<td>
   			BooleanExpression을 사용하여 조건문을 제거하고 쿼리를 보다 직관적으로 변경
    		</td>
	</tr>
</table>

<pre>
<code>
 [Before]
 @Override
  public Page<MissingPost> findByFilter(MissingFilterDto filter, Pageable pageable) {
    QMissingPost qMissing = QMissingPost.missingPost;
    QMissingPostImage qImage = QMissingPostImage.missingPostImage;

    BooleanBuilder builder = new BooleanBuilder();

    builder.and(qMissing.isActive.eq(isActive));

    if (filter.getAnimalType() != null) {
      builder.and(qMissing.animalType.equalsIgnoreCase(filter.getAnimalType()));
    }

    if (filter.getFromDate() != null) {
      builder.and(qMissing.missingTime.goe(filter.getFromDate()));
    }

    if (filter.getEndDate() != null) {
      builder.and(qMissing.missingTime.loe(filter.getEndDate()));
    }

    if (filter.getSearch() != null && !filter.getSearch().isBlank() && !filter.getSearch().isEmpty()) {
      builder.and(qMissing.title.containsIgnoreCase(filter.getSearch()));
    }

    List<MissingPost> results = queryFactory
            .selectFrom(qMissing).distinct()
            .where(builder)
            .innerJoin(qMissing.images, qImage)
            .offset(pageable.getOffset())
            .limit(pageable.getPageSize())
            .orderBy()
            .fetch();

    long total = queryFactory
            .select(qMissing.missingId.count())
            .where(qMissing.isActive.eq(isActive))
            .from(qMissing)
            .fetchOne();

    return new PageImpl<>(results, pageable, total);
  }
</code>
</pre>

<pre>
<code>
 [After]
 @Override
  public Page<MissingPost> findByFilter(MissingFilterDto filter, Pageable pageable) {

    List<MissingPost> results = queryFactory
            .selectFrom(qMissing)
            .innerJoin(qMissing.images, qImage).fetchJoin()
            .where(getFilterExpressions(filter))
            .offset(pageable.getOffset())
            .limit(pageable.getPageSize())
            .orderBy(qMissing.updatedAt.desc())
            .fetch();

    long total = queryFactory
            .select(qMissing.missingId.count())
            .where(getFilterExpressions(filter))
            .from(qMissing)
            .fetchOne();

    return new PageImpl<>(results, pageable, total);
  }

  private BooleanExpression[] getFilterExpressions(MissingFilterDto filter) {

    return new BooleanExpression[] {
            eqAnimalType(filter.getAnimalType()),
            eqSpecifics(filter.getSpecifics()),
            containKeyword(filter.getSearch()),
            eqColor(filter.getColor()),
            goeFromDate(filter.getFromDate()),
            loeEndDate(filter.getEndDate()),
            eqIsActive(isActive)
    };
  }

  private BooleanExpression eqAnimalType(String animalType) {
    if (StringUtils.isNullOrEmpty(animalType)) {
      return null;
    }
    return qMissing.animalType.equalsIgnoreCase(animalType);
  }

  private BooleanExpression containKeyword(String keyword) {
    if (StringUtils.isNullOrEmpty(keyword)) {
      return null;
    }
    return qMissing.title.containsIgnoreCase(keyword);
  }
	...
</code>
</pre>

<hr/>
</details>

<details>
<summary>이경진</summary>

<table>
  	<tr>
  		<td align="center">
      			Before
    		</td>
		<td>
      			작성 예정
    		</td>
  	</tr>
	<tr>
		<td align="center">
			After
		</td>
		<td>
   			작성 예정
    		</td>
	</tr>
</table>
</details>

<details>
<summary>손승범</summary>

<hr/>

- 📌 [[코드 확인]](https://github.com/SesacAcademy/SesacAnimal/blob/dev/src/main/java/com/project/animal/global/common/resolver/MemberDtoArgumentResolver.java#L37)

<table>
  	<tr>
  		<td align="center">
      			Before
    		</td>
		<td>
      			제목, 작성자, 내용에 따른 검색 시에 요구되는 api와 1대1 매핑관계 형성<br> 
				추가되는 기능에 따른 메소드 증가로 인한 불필요한 코드 증가
    		</td>
  	</tr>
	<tr>
		<td align="center">
			After
		</td>
		<td>
   			동적 쿼리를 작성하여 변경, 수정사항이 생길 시에 where절만 수정하게끔 변경
    		</td>
	</tr>
</table>

<pre>
<code>
        public ReadListGeneric<ReadListGeneric> readBySearch(String type, String keyword, Integer page, int size) {
            switch (type){
                case "view":
                    return readByView(page ,size, keyword);
                case "author":
                    return readByName(page ,size, keyword);
                case "title":
                    return readByTitle(page,size,keyword);
                case "content":
                    return readByContent(page, size, keyword);
            }
            return null;
        }

		// 내용 검색
        @Transactional(readOnly = true)
        private ReadListGeneric<ReadListGeneric> readByContent(Integer page, int size, String content) {
            Pageable pageable = createPageByCreatedAt(page,size);
            Page<ReviewPost> postList = reviewRepository.findAllWithMemberAndImageByContent(content, pageable);
            return entityToDtoByReadAll(postList);
        }

		// 제목 검색
        @Transactional(readOnly = true)
        private ReadListGeneric<ReadListGeneric> readByTitle(Integer page, int size, String title) {
            Pageable pageable = createPageByCreatedAt(page,size);
            Page<ReviewPost> postList = reviewRepository.findAllWithMemberAndImageByTitle(title,pageable);
            return entityToDtoByReadAll(postList);
        }

		//유저 닉네임으로 검색
        @Transactional(readOnly = true)
        private ReadListGeneric readBynickName(Integer page, int size, String nickname) {
            Pageable pageable = createPageByCreatedAt(page,size);
            Page<ReviewPost> postList = reviewRepository.findAllWithMemberAndImageByNickname(nickname,pageable);
            return entityToDtoByReadAll(postList);
        }
</code>
</pre>

<pre>
<code>
		// 닉네임 검색 쿼리
		@Query(value = "SELECT p FROM ReviewPost p JOIN FETCH p.member m LEFT JOIN FETCH p.reviewImages i WHERE m.nickname = :nickname AND p.isActive = 1",
				countQuery = "SELECT count(p.id) FROM ReviewPost p JOIN p.member m WHERE m.nickname = :nickname AND p.isActive = 1")
		Page<ReviewPost> findAllWithMemberAndImageByNickname(@Param("nickname") String nickname, Pageable pageable);


		// 제목 검색 쿼리
		@Query(value = "SELECT p FROM ReviewPost p JOIN FETCH p.member m LEFT JOIN FETCH p.reviewImages i WHERE p.title LIKE %:title% AND p.isActive = 1",
				countQuery = "SELECT count(p.id) FROM ReviewPost p WHERE p.title LIKE %:title% AND p.isActive = 1")
		Page<ReviewPost> findAllWithMemberAndImageByTitle(@Param("title") String title, Pageable pageable);


		//내용 검색 쿼리
		@Query(value = "SELECT p FROM ReviewPost p JOIN FETCH p.member m LEFT JOIN FETCH p.reviewImages i WHERE p.content LIKE %:content% AND p.isActive = 1",
				countQuery = "SELECT count(p.id) FROM ReviewPost p WHERE p.content LIKE %:content% AND p.isActive = 1")
		Page<ReviewPost> findAllWithMemberAndImageByContent(@Param("content") String content, Pageable pageable);
</code>
</pre>

<pre>
<code>
	// 검색 관련 서비스 로직
    @Transactional(readOnly = true)
    public readList readByKeyword(String type, Integer page, int size, String keyword) {
        Pageable pageable = createPageByCreatedAt(page,size);
        Page<ReviewPost> postList = reviewPostCustomRepository.findAllWithMemberAndImageByTypeAndKeyword(type, keyword,pageable);
        return entityToDtoByReadAll(postList);
    }
</code>
</pre>

<pre>
<code>
    // 제목, 작성자, 내용 검색 따른 동적 쿼리 작성
    // 투원 관계 - > 패치조인, 투 매니(컬렉션) 관계 -> 배치 활용
    public Page<ReviewPost> findAllWithMemberAndImageByTypeAndKeyword(String type, String keyword, Pageable pageable) {
        QReviewPost reviewPost = QReviewPost.reviewPost;
        QMember member = QMember.member;

        BooleanBuilder builder = new BooleanBuilder();
        builder.and(reviewPost.isActive.eq(1));

        if(type != null && keyword != null) {
            switch(type) {
                case "author":
                    builder.and(member.nickname.eq(keyword));
                    break;
                case "title":
                    builder.and(reviewPost.title.eq(keyword));
                    break;
                case "content":
                    builder.and(reviewPost.content.contains(keyword));
                    break;
            }
        }
        List<ReviewPost> content = jpaQueryFactory
                .selectFrom(reviewPost)
                .leftJoin(reviewPost.member, member).fetchJoin()
                .where(builder)
                .orderBy(reviewPost.createdAt.desc())
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize())
                .fetch();

        long total = jpaQueryFactory
                .selectFrom(reviewPost)
                .where(builder)
                .fetchCount();

        return new PageImpl<>(content, pageable, total);
    }
</code>
</pre>


</details>

<br/>

## 📋 프로젝트를 진행하며 느낀 점

<details>
<summary>박성수</summary>

- 프로젝트를 진행하며 현재 나의 위치와 수준을 파악할 수 있었습니다.

- 리팩토링 과정을 거치게 되면서, 테스트 코드의 중요성을 깨닫게 되었습니다.

</details>

<details>
<summary>류명한</summary>

- 효율적인 협업을 위해서는 커뮤니케이션이 중요하다고 다시 한번 느꼈습니다.

- 데일리 스크럼이 효과가 있다는 것을 느꼈습니다.

</details>

<details>
<summary>이경진</summary>

- 확장성을 고려한 설계가 중요하다고 생각했습니다. 설계를 하더라도 수정사항이 생기게 되는데 미리 구상하고 설계를 하면 업무가 수월하다는 걸 느꼈습니다.

- 효율적인 업무를 위해서 커뮤니케이션이 중요하다고 느꼈습니다. 공통의 작업과 일정과 업무를 정할 때도 커뮤니케이션이 원활해야 순조롭게 진행되는 점을 느꼈습니다.

- 데일리 스크럼을 통하여 작업 진행 사항을 바로 파악하여 조정해보았는데 좋은 경험이었습니다.

</details>

<details>
<summary>손승범</summary>

- 팀의 목표를 기간별로 나누어 수행하는 것이 2가지 측면에서 이점이 있음을 알게되었습니다.

 1. 나의 수준과 역량을 파악할 수 있다.
     
 2. 프로젝트 진행에 대한 피드백을 빠르게 가질 수 있다.
     
- 단순 코드를 치는 것보다 고민을 하는 시간을 가지는 것이 2가지 측면에서 이점이 있다는 것을 배웠습니다.

 1. 미시적 관점보다 거시적 관점에서 해당 로직을 바라볼 수 있다.
 
 2. 하고 있는 과업에 대해 단계별 접근이 가능하다.
</details>
